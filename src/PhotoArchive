#!/usr/bin/php
<?php

define('PHOTO', 'photo');
define('MOVIE', 'movie');

class PhotoArchive {

  public function help() {
    $help = <<<EOT
PhotoArchive
Usage:  PhotoArchive COMMAND [OPTION...]

Commands:
  archive - Archives the set of images from the picture_directory identified in the configuration file to the originals_directory.  Information will be added to the originals database for all images that are archived.

  archive-movies - Archives the set of movies from the picture_directory identified in the configuration file to the movies_directory.  Information will be added to the database for all movies that are archived.

  archive-info - Prints information about the specified photos within the orgininals archive.  Pass the photo id of each image you are interested in as arguments.

  categorize - Takes a directory full of images and categorizes them based on whether they are already known to the system (duplicates/), they are known but the directory contains a higher resolution image (replace/), or whether they are unknown to the database (new/).

  replace - Takes a photo filename, finds the closest match, and replaces the photo in the archive with the new one.  This only works if the new one actually matches one of the photos in the archive and is larger than the one in the archive.

  help - Prints a help message

  info - Prints information about the specified photos within the photo database.

  list - Prints information about the specified photos within the photo database.

  list-movies - Prints information about the specified movies within the photo database.

  tags - Prints tag information about the specified photos.

  fetch - Fetches specified photos.  By default the sharable size photo is fetched.
         --full-size - Fetch the full size JPEG image instead.
         --original-size - Fetch the original image instead.
	 --rename - Rename each file to be unique.  This is good for checking out a lot of pictures at once.
         --tree - Create a tree of directories to store the fetched images.  The directories represent the date of each photo.

  fetch-movies - Fetches specified movies.

  remove - Removes specified photos from the archive.  They will be removed from the database and the photos will be removed.

  edit <md5sum> - Edits the image that correpsonds to the specified md5 sum.  All lower level images are regenerated from the modified image.  Note that the original image is never modified as a result.  Editing the original raw image will allow you to adjust the white balance and exposure and save those changes to the full size jpeg without actually changing the original image in the archive.

  revert - Reverts the image.  This regenerates the derivative images from the original.

  refresh - Refreshes the database checksums based on the photo files.  This is helpful when processing images on the road and then importing those modified images into a more permanent repository without having to re-edit them.

OPTIONS:

  -v - Turn on verbose mode

  -r - Specify the rank of the photos that you are interested in.  For example, -r 3 will select all photos with a rank of 3.  Also, '-r ">=3"' will select all photos with a rank of 3 or more.

  -t - Specify a tag of interest.  This will narrow the list of pictures to only those that have the specified tag.

  --from - Specify a from date.  Of the form yyyy/mm/dd.

  --to - Specify a to date.  Of the form yyyy/mm/dd.  With --from and --to you can identify the range of pictures you are interested in.

  --use-original-db - Use the original db rather than the photo db.

EOT;
    print("${help}\n");
  }

  private function includes() {
    global $app_dir;
    include_once("$app_dir/Config.php");
    include_once("$app_dir/PhotoDB.php");
    include_once("$app_dir/ArchiveDB.php");
  }

  public function printPhotoInfo($photo, $config, $db) {
    if (isset($photo->id)) {
      $out[] = "ID: " . $photo->id;
    }
    else if (isset($photo->pid)) {
      $out[] = "ID: " . $photo->pid;
    }
    $out[] = "Filename: " . $photo->filename;
    $out[] = "Rating: " . $photo->rating;
    $out[] = "Dimensions: " . $photo->width . 'x' . $photo->height;
    $out[] = "MD5: " . $photo->md5;
    if (isset($photo->id)) {
      $tags = $db->getTags($photo->id, PHOTO);
    }
    else if (isset($photo->pid)) {
      $tags = $db->getTags($photo->pid, PHOTO);
    }
    if (count($tags) > 0) {
      $out[] = "Tags: " . implode(', ', $tags);
    }
    if (isset($photo->modified)) {
      $out[] = "Modified: " . ($photo->modified ? "TRUE" : "FALSE");
    }
    print(implode("\n", $out) . "\n");
  }

  public function printMovieInfo($movie, $config, $db) {
    if (isset($movie->id)) {
      $out[] = "ID: " . $movie->id;
    }
    else if (isset($movie->mid)) {
      $out[] = "ID: " . $movie->id;
    }
    $out[] = "Filename: " . $movie->filename;
    $out[] = "Rating: " . $movie->rating;
    $out[] = "Dimensions: " . $movie->width . 'x' . $movie->height;
    $out[] = "MD5: " . $movie->md5;

    if (isset($movie->id)) {
      $tags = $db->getTags($movie->id, MOVIE);
    }
    else if (isset($movie->mid)) {
      $tags = $db->getTags($movie->mid, MOVIE);
    }
    if (count($tags) > 0) {
      $out[] = "Tags: " . implode(', ', $tags);
    }
    print(implode("\n", $out) . "\n");
  }

  /**
   * Causes the specfied photo to be archived.
   */
  private function archiveOriginalPhoto($config, $photo, $photoDB, $archiveDB, $overwrite = FALSE) {
    $archivedPhoto = new StdClass();
    $escapedPath = preg_replace('/\//', '\\\/', $config->pictureDirectory);
    $partialPath = preg_replace('/^' . $escapedPath . '/', '', $photo->filename);;
    $archivedPhoto->filename = $partialPath;
    $filename = $config->originalsDirectory . $partialPath;

    $archivedPhoto->width = $photo->width;
    $archivedPhoto->height = $photo->height;
    $archivedPhoto->exposure_time = $photo->exposure_time;
    $archivedPhoto->rating = $photo->rating;
    $archivedPhoto->modified = FALSE;

    // Get the photo tags...
    $tags = $photoDB->getTags($photo->id, PHOTO);
    $archivedPhoto->tags = $tags;

    if (!$overwrite && file_exists($filename)) {
      // Do nothing - the file already exists.
      print("Skipping file $filename\n");
    }
    else {
      print("Copying file $filename\n");
      // Create the directory if needed...
      $dir = dirname($filename);
      if (!file_exists($dir)) {
        mkdir($dir, 0755, TRUE);
      }

      if (!copy($photo->filename, $filename)) {
        throw new Exception("Failed to copy " . $photo->filename . " to ${filename}");
      }
      $this->setPhotoTimestamp($filename);
    }

    $archivedPhoto->md5 = md5_file($filename);
    $this->createJPEG($config, $archivedPhoto, $archiveDB, $overwrite);
    $this->createWebJPEG($config, $archivedPhoto, $archiveDB, $overwrite);
    $archiveDB->updatePhoto($archivedPhoto);
  }

  /**
   * Causes the specfied movie to be archived.
   */
  private function archiveMovie($config, $movie, $photoDB, $archiveDB, $overwrite = FALSE) {
    $archivedMovie = new StdClass();
    $escapedPath = preg_replace('/\//', '\\\/', $config->pictureDirectory);
    $partialPath = preg_replace('/^' . $escapedPath . '/', '', $movie->filename);;
    $archivedMovie->filename = $partialPath;
    $filename = $config->movieDirectory . $partialPath;

    $archivedMovie->width = $movie->width;
    $archivedMovie->height = $movie->height;
    $archivedMovie->exposure_time = $movie->exposure_time;
    $archivedMovie->rating = $movie->rating;
    $archivedMovie->modified = FALSE;

    // Get the photo tags...
    $tags = $photoDB->getTags($movie->id, MOVIE);
    $archivedMovie->tags = $tags;

    if (!$overwrite && file_exists($filename)) {
      // Do nothing - the file already exists.
      print("Skipping file $filename\n");
    }
    else {
      print("Copying file $filename\n");
      // Create the directory if needed...
      $dir = dirname($filename);
      if (!file_exists($dir)) {
        mkdir($dir, 0755, TRUE);
      }

      if (!copy($movie->filename, $filename)) {
        throw new Exception("Failed to copy " . $movie->filename . " to ${filename}");
      }
      touch($filename, $movie->exposure_time);
    }

    $archivedMovie->md5 = md5_file($filename);
    $archiveDB->updateMovie($archivedMovie);
  }

  private function createJPEG($config, &$photo, $db, $overwrite = FALSE) {
    $original = $config->originalsDirectory . $photo->filename;
    $parts = pathinfo($photo->filename);
    $jpeg_filename = $parts['dirname'] . '/' . $parts['filename'] . '.JPG';
    $jpeg = $config->jpegsDirectory . $jpeg_filename;
    $modified_filename = $config->pictureDirectory . $parts['dirname'] . '/' . $parts['filename'] . '_modified.';

    if (!$overwrite && file_exists($jpeg)) {
      // The file exists, do nothing.
    }
    else {
      // Create the directory if needed...
      $dir = dirname($jpeg);
      if (!file_exists($dir)) {
        mkdir($dir, 0755, TRUE);
      }

      // Is there a modified picture available?
      if (file_exists($modified_filename . 'JPG')) {
        $modified = $modified_filename . 'JPG';
      }
      else if (file_exists($modified_filename . 'jpg')) {
        $modified = $modified_filename . 'jpg';
      }
      if (!empty($modified)) {
        if (!copy ($modified, $jpeg)) {
          throw new Exception("Failed to copy ${modified} to ${jpeg}.");
        }
        $photo->modified = TRUE;
      }
      else {
        $type = $this->getPhotoType($original);
        switch ($type) {
          case 'JPG':
            // No conversion needed.
            if (!copy ($original, $jpeg)) {
              throw new Exception("Failed to copy ${original} to ${jpeg}.");
            }
            break;

          case 'NEF':
            if ($config->verbose) {
              print("converting " . $original . " to ${jpeg}\n");
            }
            $command = sprintf("ufraw-batch --compression=99 --wb=camera --exposure=0.0 --base-curve=camera --overwrite --out-type=jpeg --output=%s %s 2>&1",
                       escapeshellarg($jpeg), escapeshellarg($original));
            $output = array();
            exec($command, $output, $result);
            if ($result !== 0) {
              // Something bad happened.
              throw new Exception("Failed to convert file ${original} to ${jpeg}.  " . implode('; ', $output));
            }
            break;

          default:
            throw new Exception("Unexpected file type: ${type}.");
        }
      }
      $this->setPhotoRating($jpeg, $photo->rating);
      $this->setPhotoTags($jpeg, $photo->tags);
      $this->setPhotoTimestamp($jpeg);
    }
    $photo->jpeg_filename = $jpeg_filename;
    $photo->jpeg_md5 = md5_file($jpeg);
  }

  private function createWebJPEG($config, &$photo, $db, $overwrite = FALSE) {
    $full_filename = $config->jpegsDirectory . $photo->jpeg_filename;
    $web_filename = $config->shareDirectory . $photo->jpeg_filename;

    if (!$overwrite && file_exists($web_filename)) {
      // The file exists already.
    }
    else {
      // Create the directory if needed...
      $dir = dirname($web_filename);
      if (!file_exists($dir)) {
        mkdir($dir, 0755, TRUE);
      }
      list($width, $height) = getimagesize($full_filename);
      $matches = array();
      if (preg_match('/^([0-9]+)[xX]([0-9]+)$/', $config->shareResolution, $matches) != 1) {
        die(sprintf("Invalid share_resolution in your config file: %s\n", $config->shareResolution));
      }
      $share_width = $matches[1];
      $share_height = $matches[2];
      // Figure out the dimensions of the reduced image.
      if ($width > $height) {
        $w = (int)round($share_width);
        $h = (int)round(($height * $w) / $width);
      }
      else {
        $h = (int)round($share_height);
        $w = (int)round(($width * $h) / $height);
      }
      $size_str = sprintf('%sx%s', $w, $h);
      $command = sprintf('convert %s -resize %s -extent %s -quality %s %s',
                 escapeshellarg($full_filename), escapeshellarg($size_str), escapeshellarg($size_str), escapeshellarg($config->quality), escapeshellarg($web_filename));
      $output = array();
      exec($command, $output, $result);
      if ($result !== 0) {
        // Something bad happened.
        throw new Exception("Failed to scale image file ${full_filename} to ${web_filename}.  " . implode('; ', $output));
      }

      $this->setPhotoTimestamp($web_filename);
    }
    $photo->web_filename = $photo->jpeg_filename;
    $photo->web_md5 = md5_file($web_filename);
  }

  private function getPhotoType($filename) {
    $info = pathinfo($filename);
    $ext = strtoupper($info['extension']);
    return $ext;
  }

  private function copyPhoto($from, $to) {
    // Copy the file, preserving the timestamp, etc.
    $copy = 'cp -p ' . escapeshellarg($from) . ' ' . escapeshellarg($to);
    $output = array();
    exec($copy, $output, $result);
    if ($result !== 0) {
      // Something bad happened.
      throw new Exception("Failed to copy file " . $from . " to ${to}.  " . implode('; ', $output));
    }
  }

  private function setPhotoRating($filename, $rating) {
    // Invoke exiv2 to set the rating.
    if ($rating < 0 || $rating > 5) {
      // This is not a legal rating.
      throw new Exception("Rating must be between 0 and 5, inclusive.  Instead it was ${rating} for file ${filename}.");
    }
    $command = sprintf('exiv2 -M"add Xmp.xmp.Rating %s" %s',
      $rating, escapeshellarg($filename));
    $output = array();
    exec($command, $output, $result);
    if ($result !== 0) {
      // Something bad happened.
      throw new Exception("Failed to set the rating of file ${filename} to ${rating}.  Command: ${command}; " . implode('; ', $output));
    }
  }

  private function setPhotoTags($filename, $tags) {
    if (empty($tags)) {
      return;
    }
    $tagString = $this->cutTagsToSize(implode(',', $tags));
    if (count($tagString) > 0) {
      // Invoke exiv2 to set the tags.
      if (strlen($tagString) > 64) {
        throw new Exception("The tags cannot exceed 64 characters for image ${filename} (tags are '${tagString}'.");
      }
      $command = sprintf('exiv2 -M"add Iptc.Application2.Keywords %s" %s',
        $tagString, escapeshellarg($filename));
      $output = array();
      exec($command, $output, $result);
      if ($result !== 0) {
        // Something bad happened.
        throw new Exception("Failed to set the tags of file ${filename} to ${tagString}.  Command: ${command};  " . implode('; ', $output));
      }
    }
  }

  /**
   * Takes a tag string and ensures that it is not larger than the specified
   * maximum length.
   *
   * If the string is longer than the maximum length, the tags are removed
   * (longest one first) until the tags will fit in the specified space.
   */
  private function cutTagsToSize($tag_string, $max_len = 64) {
    $len = strlen($tag_string);
    if ( $len > $max_len) {
      $elements = explode(',', $tag_string);
      usort($elements, 'PhotoArchive::strLenSort');
      $total = 0;
      while (count($elements) > 0 && $len - $total > $max_len) {
        $tag = array_shift($elements);
        $total += strlen($tag) + 1;
      }
      $tag_string = implode(',', $elements);
    }
    return $tag_string;
  }

  /**
   * Sort function that sorts two strings by their length in reverse order.
   *
   * This is used to sort the tags in the case that the length of the tags
   * string is too long to figure out which tag(s) should be removed.
   */
  public static function strLenSort($a, $b) {
    return (strlen($a) - strlen($b));
  }

  private function setPhotoTimestamp($filename) {
    // Invoke exiv2 to set the timestamp to that of the exif data in the photo.
    $command = sprintf('exiv2 -T rename %s',
      escapeshellarg($filename));
    $output = array();
    exec($command, $output, $result);
    if ($result !== 0) {
      // Something bad happened.
      throw new Exception("Failed to set the timestamp of file ${filename}.  Command: ${command};  " . implode('; ', $output));
    }
  }

  public function parseArgs() {
    global $argv, $argc;
    // Make sure there is a command.
    if ($argc <= 1) {
      $this->help();
      return;
    }
    $major_command = $argv[1];

    // Parse all flags
    $config = new Config();
    $args = new StdClass();
    $args->rename = FALSE;
    $args->tree = FALSE;
    $done = FALSE;
    $extraArgs = array();
    for ($i = 2; $i < $argc && !$done; $i++) {
      switch ($argv[$i]) {
        case '-v':
          $config->setVerbose();
          break;

        case '-y':
          $args->year = $argv[++$i];
          break;

        case '-m':
          $args->month = $argv[++$i];
          break;

        case '-d':
          $args->day = $argv[++$i];
          break;

        case '-r':
        case '--rate':
          $args->rating = $argv[++$i];
          break;

        case '-t':
        case '--tag':
          $args->tag = $argv[++$i];
          break;

        case '--from':
          // format: yyyy/mm/dd
          $args->from = $argv[++$i];
          break;

        case '--to':
          // format: yyyy/mm/dd
          $args->to = $argv[++$i];
          break;

        case '--use-original-db':
	  $args->db = 'original';
	  break;

        case '--full-size':
          $args->photo_size = 'full';
          break;

        case '--original-size':
          $args->photo_size = 'original';
          break;

        case '--rename':
	  $args->rename = TRUE;
	  break;

        case '--tree':
	  $args->tree = TRUE;
	  break;

        default:
          while ($i < $argc) {
            $extraArgs[] = $argv[$i++];
          }
          $done = TRUE;
      }
    }

    $conf = $config->getConfiguration();
    // Now we have $config and $extraArgs...
    switch ($major_command) {
      case 'info':
        $this->info($conf, $args, $extraArgs);
        break;

      case 'archive-info':
        $this->archiveInfo($conf, $args, $extraArgs);
        break;

      case 'categorize':
        $this->categorize($conf, $args, $extraArgs);
        break;

      case 'replace':
        $this->replace($conf, $args, $extraArgs);
        break;

      case 'tags':
        $this->tags($conf, $args, $extraArgs);
        break;

      case 'list':
        $this->listPhotos($conf, $args, $extraArgs);
        break;

      case 'list-movies':
        $this->listMovies($conf, $args, $extraArgs);
        break;

      case 'archive':
        $this->archive($conf, $args, $extraArgs);
        break;

      case 'archive-movies':
        $this->archiveMovies($conf, $args, $extraArgs);
        break;

      case 'fetch':
        $this->fetch($conf, $args, $extraArgs);
        break;

      case 'fetch-movies':
        $this->fetchMovies($conf, $args, $extraArgs);
        break;

      case 'remove':
        $this->remove($conf, $args, $extraArgs);
        break;

      case 'edit':
        $this->edit($conf, $args, $extraArgs);
        break;

      case 'revert':
        $this->revert($conf, $args, $extraArgs);
        break;

      case 'refresh':
        $this->refresh($conf, $args, $extraArgs);
        break;

      default:
        $this->help();
    }
  }

  public function info($config, $args, $extraArgs) {
    $photoDB = new PhotoDB($config);
    for ($i = 0, $len = count($extraArgs); $i < $len; $i++) {
      $photoId = $extraArgs[$i];
      $tags = $photoDB->getTags($photoId, PHOTO);
      print("${photoId}: " . implode(', ', $tags) . "\n");
    }
    $photoDB->close();
  }

  /**
   * Prints info about specific photos in the original archive.
   */
  public function archiveInfo($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    for ($i = 0, $len = count($extraArgs); $i < $len; $i++) {
      $photoId = $extraArgs[$i];
      $photo = $archiveDB->loadPhoto($config, $photoId);
      print("Photo ${photoId}: ");
      print_r($photo);
      print("\n");
    }
    $archiveDB->close();
  }

  /**
   * Categorizes the photos specified on the command line by filename into 3 buckets.
   *
   * new: These photos are not currently in the photo archive.
   * duplicates: These photos are already in the photo archive
   * replace: These photos are already in the archive, but the archive contains a smaller version of the file.  It is recommended that these photos be replaced in the archive.
   *
   * @param {Config} $config
   *   The configuration object that identifies where the database and photo
   *   directories are.
   * @param {StdClass} $args
   *   The processed command line arguments that identify which of the photo
   *   variants the user is interested in.
   * @param {Array} $extraArgs
   *   Additional command line arguments that do not constitute PhotoArchive
   *   options.
   */
  public function categorize($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    mkdir('./new', 0755, TRUE);
    mkdir('./duplicates', 0755, TRUE);
    mkdir('./replace', 0755, TRUE);

    for ($i = 0, $len = count($extraArgs); $i < $len; $i++) {
      $filename = $extraArgs[$i];
      $photo = $archiveDB->findClosestPhotoMatch($config, $args, $filename);
      if (!empty($photo)) {
        // Is this an exact match?  Compare the file sizes.
        $filesize = filesize($filename);
        $photo_filename = $this->getFilename($config, $photo, 'original');
        if (filesize($filename) > filesize($photo_filename)) {
          // Put into the 'replace/' directory
          print("Photo ${filename} should replace ${photo_filename} in the archive.\n");
          rename($filename, './replace/' . basename($filename));
        }
        else {
          // Put into the 'duplicates/' directory.
          print("Photo ${filename} already exists.\n");
          rename($filename, './duplicates/' . basename($filename));
        }
      }
      else {
        // Put into the 'new/' directory
        print("Photo ${filename} does not exist in the database.\n");
        rename($filename, './new/' . basename($filename));
      }
    }
    $archiveDB->close();
  }

  public function replace($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    for ($i = 0, $len = count($extraArgs); $i < $len; $i++) {
      $filename = $extraArgs[$i];
      $photo = $archiveDB->findClosestPhotoMatch($config, $args, $filename);
      if (!empty($photo)) {
        // Is this an exact match?  Compare the file sizes.
        $filesize = filesize($filename);
        $photo_filename = $this->getFilename($config, $photo, 'original');
        if (filesize($filename) > filesize($photo_filename)) {
          // Put into the 'replace/' directory
          print("Replacing photo ${photo_filename} with ${filename} in the archive.\n");
          $orig_filename = $this->getFilename($config, $photo, 'original');
          $new_filename = dirname($orig_filename) . '/' . basename($filename);

          // Move the file into the /tmp directory.
          $tmp_file = '/tmp/' . basename($orig_filename);
          rename($orig_filename, $tmp_file);

          // Copy the file into the archive.
          copy($filename, $new_filename);
          touch($new_filename, $photo->exposure_time);

          // Update the database.
          $archiveDB->replacePhoto($photo, $filename);
          print("New md5 is " . $photo->md5 . "\n");

          // Update the derivative images.
          $this->revert($config, $args, array($photo->md5));
        }
        else {
          // Put into the 'duplicates/' directory.
          print("Not replacing photo ${filename} because it already exists.\n");
        }
      }
      else {
        // Put into the 'new/' directory
        print("Photo ${filename} does not exist in the database.\n");
      }
    }
    $archiveDB->close();
  }

  public function listPhotos($config, $args, $extraArgs) {
    if (isset($args->db) && $args->db == 'original') {
      $db = new ArchiveDB($config);
    }
    else {
      $db = new PhotoDB($config);
    }
    $photos = $db->getPhotos($config, $args);
    $count = 0;
    while ($photo = $photos->fetchObject()) {
      $this->printPhotoInfo($photo, $config, $db);
      $count++;
    }
    print("${count} photos.\n");
    $db->close();
  }

  public function listMovies($config, $args, $extraArgs) {
    if (isset($args->db) && $args->db == 'original') {
      $db = new ArchiveDB($config);
    }
    else {
      $db = new PhotoDB($config);
    }
    $movies = $db->getMovies($config, $args);
    $count = 0;
    while ($movie = $movies->fetchObject()) {
      $this->printMovieInfo($movie, $config, $db);
      $count++;
    }
    print("${count} movies.\n");
    $db->close();
  }

  public function tags($config, $args, $extraArgs) {
    $photoDB = new PhotoDB($config);
    $tags = $photoDB->getAllTags();
    $photoDB->close();
  }

  public function archive($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    $photoDB = new PhotoDB($config);
    $photos = $photoDB->getPhotos($config, $args);
    $count = 0;
    while ($photo = $photos->fetchObject()) {
      $this->archiveOriginalPhoto($config, $photo, $photoDB, $archiveDB);
      $count++;
    }
    print("${count} photos matched your query.\n");
    $photoDB->close();
  }

  public function archiveMovies($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    $photoDB = new PhotoDB($config);
    $movies = $photoDB->getMovies($config, $args);
    $count = 0;
    while ($movie = $movies->fetchObject()) {
      $this->archiveMovie($config, $movie, $photoDB, $archiveDB);
      $count++;
    }
    print("${count} movies matched your query.\n");
    $photoDB->close();
  }

  public function fetch($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    $photos = $archiveDB->getPhotos($config, $args);
    $count = 0;
    switch (count($extraArgs)) {
      case 0:
        $dest = getcwd();
        break;

      case 1:
        $dest = $extraArgs[0];
        break;

      default:
        throw new Exception("Destination directory is not specified.");
    }
    if (!is_dir($dest)) {
      throw new Exception("Destination directory ${dest} does not exist or is not a directory.");
    }

    $prefix = $config->shareDirectory;
    while ($photo = $photos->fetchObject()) {
      $from = $this->getPhotoFilename($config, $args, $photo);
      $to = $dest . "/" . basename($from);
      if (TRUE === $args->tree) {
	$to_dir = sprintf('%s%s', $dest, dirname($photo->filename));
	$to = sprintf('%s/%s', $to_dir, basename($from));
	if (!file_exists($to_dir)) {
	  $mkdir_out = array();
	  exec(sprintf('mkdir -p %s', $to_dir), $mkdir_out, $mkdir_result);
	  if ($mkdir_result !== 0) {
	    print_r($mkdir_out);
	    break;
	  }
	}
      }

      if (!@copy($from, $to)) {
        print("Failed to copy ${from} to ${to}.\n");
      }
      else {
        $this->setPhotoTimestamp($to);
        print("Copied ${from} to ${to}.\n");

	if (TRUE === $args->rename) {
	  // Rename the file to be unique.
	  $rename_command = sprintf('exiv2 rename -F %s', escapeshellarg($to));
	  $output = array();
	  exec($rename_command, $output, $rename_result);
	  if (0 !== $rename_result) {
	    printf("Failed to rename %s\n", $to);
	  }
	}
      }
      $count++;
    }
    print("${count} photos matched your query.\n");
    $archiveDB->close();
  }

  public function fetchMovies($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    $movies = $archiveDB->getMovies($config, $args);
    $count = 0;
    switch (count($extraArgs)) {
      case 0:
        $dest = getcwd();
        break;

      case 1:
        $dest = $extraArgs[0];
        break;

      default:
        throw new Exception("Destination directory is not specified.");
    }
    if (!is_dir($dest)) {
      throw new Exception("Destination directory ${dest} does not exist or is not a directory.");
    }

    $prefix = $config->movieDirectory;
    while ($movie = $movies->fetchObject()) {
      $from = $config->movieDirectory . '/' . $movie->filename;
      $to = $dest . "/" . basename($from);
      if (!@copy($from, $to)) {
        print("Failed to copy ${from} to ${to}.\n");
      }
      else {
        touch($to, $movie->exposure_time);
        print("Copied ${from} to ${to}.\n");
      }
      $count++;
    }
    print("${count} movies matched your query.\n");
    $archiveDB->close();
  }

  /**
   * Returns the correct path to the photo based on the command line arguments.
   *
   * This is currently used in the fetch method to allow the user to identify
   * which variant of the photo is desired.
   *
   * @param {Config} $config
   *   The configuration object that identifies where the database and photo
   *   directories are.
   * @param {StdClass} $args
   *   The processed command line arguments that identify which of the photo
   *   variants the user is interested in.
   * @param {StdClass} $photo
   *   A representation of the photo, loaded from the database.
   */
  private function getPhotoFilename($config, $args, $photo) {
    if (empty($args->photo_size)) {
      $type = 'web';
    }
    else {
      $type = $args->photo_size;
    }
    return $this->getFilename($config, $photo, $type);
  }

  /**
   * Returns the correct path to the photo based on the command line arguments.
   *
   * This is currently used in the fetch method to allow the user to identify
   * which variant of the photo is desired.
   *
   * @param {Config} $config
   *   The configuration object that identifies where the database and photo
   *   directories are.
   * @param {StdClass} $photo
   *   A representation of the photo, loaded from the database.
   * @param {String} $type
   *   Indicates the photo variant to provide the path for.  One of 'full',
   *   'original', or 'web'.
   */
  private function getFilename($config, $photo, $type) {
    switch ($type) {
      case 'full':
        $prefix = $config->jpegsDirectory;
        $filename = $photo->jpeg_filename;
        break;

      case 'original':
        $prefix = $config->originalsDirectory;
        $filename = $photo->filename;
        break;

      case 'web':
      default:
        $prefix = $config->shareDirectory;
        $filename = $photo->web_filename;
    }
    return  str_replace('//', '/', $prefix . "/" . $filename);
  }

  public static function getAllExifData($filename) {
    $exif = array();
    $command = sprintf('exiv2 print -p a %s', escapeshellarg($filename));
    $output = array();
    exec($command, $output, $result);
    for ($i = 0, $len = count($output); $i < $len; $i++) {
      $line = $output[$i];
      $name = substr($line, 0, strpos($line, ' '));
      $line = trim(substr($line, strlen($name)));
      $type = substr($line, 0, strpos($line, ' '));
      $line = trim(substr($line, strlen($type)));
      $size = substr($line, 0, strpos($line, ' '));
      $value = trim(substr($line, strlen($size)));
      $exif[$name] = $value;
    }
    return $exif;
  }

  public static function getPhotoDimensions($filename) {
    list($width, $height) = getimagesize($filename);
    if ($width < 300 && $height < 300) {
      // This is probably a thumbnail.
      $exif = PhotoArchive::getAllExifData($filename);
      $width = $exif['Exif.SubImage2.ImageWidth'];
      $height = $exif['Exif.SubImage2.ImageLength'];
    }
    return (array($width, $height));
  }

  public function remove($config, $args, $extraArgs) {
    print("The remove command has been disabled because it is dangerous.\n");
    exit(0);
    $archiveDB = new ArchiveDB($config);
    $photos = $archiveDB->getPhotos($config, $args);
    $count = 0;
    $orig_prefix = $config->originalsDirectory;
    $jpeg_prefix = $config->jpegsDirectory;
    $share_prefix = $config->shareDirectory;
    while ($photo = $photos->fetchObject()) {
      $orig = $orig_prefix . $photo->filename;
      $jpeg = $jpeg_prefix . $photo->jpeg_filename;
      $share = $share_prefix . $photo->web_filename;
      if (!@unlink($orig)) {
        print("Failed to delete ${orig}.\n");
      }
      if (!@unlink($jpeg)) {
        print("Failed to delete ${jpeg}.\n");
      }
      if (!@unlink($share)) {
        print("Failed to delete ${share}.\n");
      }
      print('Deleting photo ' . $photo->filename . "\n");
      $archiveDB->remove($config, $photo);
      $count++;
    }
    print("${count} photos matched your query.\n");
    $archiveDB->close();
  }

  public function edit($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    for ($i = 0, $len = count($extraArgs); $i < $len; $i++) {
      $md5 = $extraArgs[$i];
      $photo = $archiveDB->getPhotoByMD5($config, $args, $md5);
      if (!empty($photo) && $md5 == $photo->md5) {
        // Modifying the original.  Never actually save over the original.
        $src = $this->getFilename($config, $photo, 'original');
        $dst = $this->getFilename($config, $photo, 'full');
      }
      if (!empty($photo) && $md5 == $photo->jpeg_md5) {
        // Modifying the full size jpeg.
        $src = $this->getFilename($config, $photo, 'full');
        $dst = $this->getFilename($config, $photo, 'full');
      }
      if (!empty($photo) && $md5 == $photo->web_md5) {
        // Modifying the sharable size.
        $src = $this->getFilename($config, $photo, 'web');
        $dst = $this->getFilename($config, $photo, 'web');
      }
      if (!empty($src) && !empty($dst)) {
        $this->editPhoto($config, $archiveDB, $photo, $src, $dst, $md5);
      }
      else {
        print("Could not find photo with md5 of ${md5}.\n");
      }
    }
  }

  /**
   * Edits the specified photo.  The changes are never saved to the original
   * image.  Any change done to the full size jpeg is replicated onto the
   * sharable size also.
   *
   * @param {Config} $config
   *   The configuration object that identifies where the database and photo
   *   directories are.
   * @param {ArchiveDB} $archiveDB
   *   The archiveDB instance.
   * @param {StdClass} $photo
   *   A representation of the photo, loaded from the database.
   * @param {String} $srcfilename
   *   The filename of the source image.
   * @param {String} $dstFilename
   *   The filename of the destination image.
   */
  public function editPhoto($config, $archiveDB, &$photo, $srcFilename, $dstFilename, $md5) {
    $compression = 99;
    $path_info = pathinfo($srcFilename);
    $type = strtoupper($path_info['extension']);

    switch($type) {
      case 'NEF':
        $command = sprintf('ufraw --out-type=jpg --compression=%d --output=%s %s', $compression, $dstFilename, $srcFilename);
        $md5_before = md5_file($dstFilename);
        $output = array();
        exec($command, $output, $result);
        // Figure out if the image was modified or not...
        $md5_after = md5_file($dstFilename);
        if ($md5_after == $md5_before) {
          // The image wasn't saved, so nothing to do.
          print("Image edit of file ${srcFilename} was aborted.\n");
        }
        else {
          $this->setPhotoTimestamp($dstFilename);
          $photo->jpeg_md5 = $md5_after;
          $this->createWebJPEG($config, $photo, $archiveDB, TRUE);
          $archiveDB->updatePhoto($photo);
          print("Saved edited image ${dstFilename}.  The new md5sum is ${md5_after}\n");
        }
        break;

      case 'JPG':
      case 'JPEG':
        // Copy the source image to /tmp, if the user saves changes, we will
        // have to copy that to the destination.
        $tmp_filename = '/tmp/' . basename($srcFilename);
        copy($srcFilename, $tmp_filename);

        $command = sprintf('gimp --no-splash %s', $tmp_filename);
        $md5_before = md5_file($tmp_filename);
        $output = array();
        exec($command, $output, $result);
        // Figure out if the image was modified or not...
        $md5_after = md5_file($tmp_filename);
        if ($md5_after == $md5_before) {
          // The image wasn't saved, so nothing to do.
          print("Image edit of file ${srcFilename} was aborted.\n");
        }
        else {
          copy($tmp_filename, $dstFilename);
          $this->setPhotoTimestamp($dstFilename);
          if ($md5 == $photo->jpeg_md5) {
            // The full size jpeg image was modified.
            $photo->jpeg_md5 = $md5_after;
            $this->createWebJPEG($config, $photo, $archiveDB, TRUE);
            $archiveDB->updatePhoto($photo);
          }
          elseif ($md5 == $photo->web_md5) {
            // The web size jpeg was modified.
            $photo->web_md5 = $md5_after;
            $archiveDB->updatePhoto($photo);
          }
          print("Saved edited image ${dstFilename}.  The new md5sum is ${md5_after}\n");}
        break;
    }
  }

  public function revert($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    if (count($extraArgs) > 0) {
      for ($i = 0, $len = count($extraArgs); $i < $len; $i++) {
        $md5 = $extraArgs[$i];
        $photo = $archiveDB->getPhotoByMD5($config, $args, $md5);
        if (!empty($photo)) {
          $this->_revertPhoto($config, $photo, $archiveDB);
        }
        else {
          print("Could not find photo associated with md5 ${md5}\n");
        }
      }
    }
    else {
      $photos = $archiveDB->getPhotos($config, $args);
      while ($photo = $photos->fetchObject()) {
        $this->_revertPhoto($config, $photo, $archiveDB);
      }
    }
  }

  private function _revertPhoto($config, $photo, $archiveDB) {
    if (!empty($photo)) {
      $photo = $archiveDB->loadPhoto($config, $photo->pid);
      $this->createJPEG($config, $photo, $archiveDB, TRUE);
      $this->createWebJPEG($config, $photo, $archiveDB, TRUE);
      $archiveDB->updatePhoto($photo);
      print('Reverted photo ' . $photo->filename . "\n");
    }
  }

  public function refresh($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    $photos = $archiveDB->getPhotos($config, $args);
    while ($photo = $photos->fetchObject()) {
      $this->_refreshPhoto($config, $photo, $archiveDB);
    }
  }

  private function _refreshPhoto($config, $photo, $archiveDB) {
    if (!empty($photo)) {
      $photo = $archiveDB->loadPhoto($config, $photo->pid);
      $changed = FALSE;

      $md5 = md5_file($photo->original_filename);
      if ($md5 !== $photo->md5) {
	$photo->md5 = $md5;
	$changed = TRUE;
      }

      $jpeg_md5 = md5_file($photo->jpeg_filename);
      if ($jpeg_md5 !== $photo->jpeg_md5) {
	$photo->jpeg_md5 = $jpeg_md5;
	$changed = TRUE;
      }

      $web_md5 = md5_file($photo->share_filename);
      if ($web_md5 !== $photo->web_md5) {
	$photo->web_md5 = $web_md5;
	$changed = TRUE;
      }

      if ($changed) {
	$archiveDB->updatePhoto($photo);
	printf("Refreshed photo %s\n", $photo->filename);
      }
      else {
	printf("Skipped photo %s\n", $photo->filename);
      }
    }
  }

  public function main() {
    // Figure out where the application lives.
    global $argv, $argc, $app_dir;
    $app_dir = dirname($argv[0]);

    $this->includes();
    $this->parseArgs();
    return;
    $pa = new PhotoArchive();
    $pa->includes();
    $c = new Config();
    $options = getopt('p:vr:t:'/*, array('rate:', 'tag:')*/);
    if (isset($options['v'])) {
      $c->setVerbose();
    }
    $config = $c->getConfiguration();;

    if (isset($options['p'])) {
      $photoId = $options['p'];
      $photoDB = new PhotoDB($config);
      $tags = $photoDB->getTags($photoId, PHOTO);
      print(implode(', ', $tags) . "\n");
      $photoDB->close();
      die();
    }
    $photoDB = new PhotoDB($config);
    $rate = empty($options['r']) ? NULL : $options['r'];
    $results = $photoDB->find($rate);
    $count = 0;
    /*
    foreach ($results as $row) {
      foreach ($row as $key => $val) {
	if (!is_numeric($key)) {
	  print "$key: $val\n";
	}
      }
      $count++;
    }
    */
    while ($photo = $results->fetchObject()) {
      /*      foreach ($result as $key => $val) {
	if (!is_numeric($key)) {
	  print "$key: $val\n";
	}
      }
      */
      $pa->archiveOriginalPhoto($config, $photo, $photoDB);
      $count++;
    }
    print("${count} photos matched your query.\n");
    $photoDB->close();
  }
}

$pa = new PhotoArchive();
$pa->main();

