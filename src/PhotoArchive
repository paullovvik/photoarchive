#!/usr/bin/php
<?php

class PhotoArchive {

  public function help() {
    $help = <<<EOT
PhotoArchive
Usage:  PhotoArchive COMMAND [OPTION...]

Commands:
  archive - Archives the set of images from the picture_directory identified in the configuration file to the originals_directory.  Information will be added to the originals database for all images that are archived.

  archive-info - Prints information about the specified photos within the orgininals archive.

  help - Prints a help message

  info - Prints information about the specified photos within the photo database.

  list - Prints information about the specified photos within the photo database.

  tags - Prints tag information about the specified photos.

  fetch - Fetches specified photos.  The photos come from the sharable directory.

OPTIONS:

  -v - Turn on verbose mode

  -r - Specify the rank of the photos that you are interested in.  For example, -r 3 will select all photos with a rank of 3.  Also, '-r ">=3"' will select all photos with a rank of 3 or more.

  -t - Specify a tag of interest.  This will narrow the list of pictures to only those that have the specified tag.

  --from - Specify a from date.  Of the form yyyy/mm/dd.

  --to - Specify a to date.  Of the form yyyy/mm/dd.  With --from and --to you can identify the range of pictures you are interested in.

  --use-original-db - Use the original db rather than the photo db.

EOT;
    print("${help}\n");
  }

  private function includes() {
    global $app_dir;
    include_once("$app_dir/Config.php");
    include_once("$app_dir/PhotoDB.php");
    include_once("$app_dir/ArchiveDB.php");
  }

  public function printPhotoInfo($photo, $config, $db) {
    if (isset($photo->id)) {
      $out[] = "ID: " . $photo->id;
    }
    else if (isset($photo->pid)) {
      $out[] = "ID: " . $photo->pid;
    }
    $out[] = "Filename: " . $photo->filename;
    $out[] = "Rating: " . $photo->rating;
    $out[] = "Dimensions: " . $photo->width . 'x' . $photo->height;
    $out[] = "MD5: " . $photo->md5;
    if (isset($photo->id)) {
      $tags = $db->getTags($photo->id);
    }
    else if (isset($photo->pid)) {
      $tags = $db->getTags($photo->pid);
    }
    if (count($tags) > 0) {
      $out[] = "Tags: " . implode(', ', $tags);
    }
    if (isset($photo->modified)) {
      $out[] = "Modified: " . ($photo->modified ? "TRUE" : "FALSE");
    }
    print(implode("\n", $out) . "\n");
  }

  /**
   * Causes the specfied photo to be archived.
   */
  private function archiveOriginalPhoto($config, $photo, $photoDB, $archiveDB, $overwrite = FALSE) {
    $archivedPhoto = new StdClass();
    $escapedPath = preg_replace('/\//', '\\\/', $config->pictureDirectory);
    $partialPath = preg_replace('/^' . $escapedPath . '/', '', $photo->filename);;
    $archivedPhoto->filename = $partialPath;
    $filename = $config->originalsDirectory . $partialPath;

    $archivedPhoto->width = $photo->width;
    $archivedPhoto->height = $photo->height;
    $archivedPhoto->exposure_time = $photo->exposure_time;
    $archivedPhoto->rating = $photo->rating;
    $archivedPhoto->modified = FALSE;

    // Get the photo tags...
    $tags = $photoDB->getTags($photo->id);
    $archivedPhoto->tags = $tags;

    if (!$overwrite && file_exists($filename)) {
      // Do nothing - the file already exists.
      print("Skipping file $filename\n");
    }
    else {
      print("Copying file $filename\n");
      // Create the directory if needed...
      $dir = dirname($filename);
      if (!file_exists($dir)) {
        mkdir($dir, 0755, TRUE);
      }

      if (!copy($photo->filename, $filename)) {
        throw new Exception("Failed to copy " . $photo->filename . " to ${filename}");
      }
      $info = pathinfo($photo->filename);
      $ext = strtoupper($info['extension']);
      if ($ext == 'JPG') {
        $this->setPhotoRating($filename, $archivedPhoto->rating);
        $this->setPhotoTags($filename, $tags);
      }
      $this->setPhotoTimestamp($filename);
    }

    $archivedPhoto->md5 = md5_file($filename);
    $this->createJPEG($config, $archivedPhoto, $archiveDB, $overwrite);
    $this->createWebJPEG($config, $archivedPhoto, $archiveDB, $overwrite);
    $archiveDB->updatePhoto($archivedPhoto);
  }

  private function createJPEG($config, &$photo, $db, $overwrite = FALSE) {
    $original = $config->originalsDirectory . $photo->filename;
    $parts = pathinfo($photo->filename);
    $jpeg_filename = $parts['dirname'] . '/' . $parts['filename'] . '.JPG';
    $jpeg = $config->jpegsDirectory . $jpeg_filename;
    $modified_filename = $config->pictureDirectory . $parts['dirname'] . '/' . $parts['filename'] . '_modified.';

    if (!$overwrite && file_exists($jpeg)) {
      // The file exists, do nothing.
    }
    else {
      // Create the directory if needed...
      $dir = dirname($jpeg);
      if (!file_exists($dir)) {
        mkdir($dir, 0755, TRUE);
      }

      // Is there a modified picture available?
      if (file_exists($modified_filename . 'JPG')) {
        $modified = $modified_filename . 'JPG';
      }
      else if (file_exists($modified_filename . 'jpg')) {
        $modified = $modified_filename . 'jpg';
      }
      if (!empty($modified)) {
        if (!copy ($modified, $jpeg)) {
          throw new Exception("Failed to copy ${modified} to ${jpeg}.");
        }
        $photo->modified = TRUE;
      }
      else {
        $type = $this->getPhotoType($original);
        switch ($type) {
          case 'JPG':
            // No conversion needed.
            if (!copy ($original, $jpeg)) {
              throw new Exception("Failed to copy ${original} to ${jpeg}.");
            }
            break;

          case 'NEF':
            print("converting " . $original . " to ${jpeg}\n");
            $command = sprintf('ufraw-batch --compression=99 --wb=auto --exposure=auto --base-curve=camera --overwrite --out-type=jpeg --output=%s %s',
                       escapeshellarg($jpeg), escapeshellarg($original));
            $output = array();
            exec($command, $output, $result);
            if ($result !== 0) {
              // Something bad happened.
              throw new Exception("Failed to convert file ${original} to ${jpeg}.  " . implode('; ', $output));
            }
            break;

          default:
            throw new Exception("Unexpected file type: ${type}.");
        }
      }
      $this->setPhotoRating($jpeg, $photo->rating);
      $this->setPhotoTags($jpeg, $photo->tags);
      $this->setPhotoTimestamp($jpeg);
    }
    $photo->jpeg_filename = $jpeg_filename;
    $photo->jpeg_md5 = md5_file($jpeg);
  }

  private function createWebJPEG($config, &$photo, $db, $overwrite = FALSE) {
    $full_filename = $config->jpegsDirectory . $photo->jpeg_filename;
    $web_filename = $config->shareDirectory . $photo->jpeg_filename;

    if (!$overwrite && file_exists($web_filename)) {
      // The file exists already.
    }
    else {
      // Create the directory if needed...
      $dir = dirname($web_filename);
      if (!file_exists($dir)) {
        mkdir($dir, 0755, TRUE);
      }
      list($width, $height) = getimagesize($full_filename);
      $matches = array();
      if (preg_match('/^([0-9]+)[xX]([0-9]+)$/', $config->shareResolution, $matches) != 1) {
        die(sprintf("Invalid share_resolution in your config file: %s\n", $config->shareResolution));
      }
      $share_width = $matches[1];
      $share_height = $matches[2];
      // Figure out the % to reduce the image...
      if ($width > $height) {
        $percent = round(("${share_width}.0" / $width) * 100);
      }
      else {
        $percent = round(("${share_height}.0" / $height) * 100);
      }
      $percent = min($percent, 100);
      print("scaling ${full_filename} to ${web_filename} by ${percent}%.\n");
      $command = sprintf('convert %s -resize %s -quality %s %s',
        escapeshellarg($full_filename), escapeshellarg("${percent}%"), escapeshellarg($config->quality), escapeshellarg($web_filename));
      $output = array();
      exec($command, $output, $result);
      if ($result !== 0) {
        // Something bad happened.
        throw new Exception("Failed to scale image file ${full_filename} to ${web_filename}.  " . implode('; ', $output));
      }

      $this->setPhotoTimestamp($web_filename);
    }
    $photo->web_filename = $photo->jpeg_filename;
    $photo->web_md5 = md5_file($web_filename);
  }

  private function getPhotoType($filename) {
    $info = pathinfo($filename);
    $ext = strtoupper($info['extension']);
    return $ext;
  }

  private function copyPhoto($from, $to) {
    // Copy the file, preserving the timestamp, etc.
    print("Copying " . $from . " to $to\n");
    $copy = 'cp -p ' . escapeshellarg($from) . ' ' . escapeshellarg($to);
    $output = array();
    exec($copy, $output, $result);
    if ($result !== 0) {
      // Something bad happened.
      throw new Exception("Failed to copy file " . $from . " to ${to}.  " . implode('; ', $output));
    }
  }

  private function setPhotoRating($filename, $rating) {
    // Invoke exiv2 to set the rating.
    print("Setting the rating of ${filename} to ${rating}.\n");
    if ($rating < 0 || $rating > 5) {
      // This is not a legal rating.
      throw new Exception("Rating must be between 0 and 5, inclusive.  Instead it was ${rating} for file ${filename}.");
    }
    $command = sprintf('exiv2 -M"add Xmp.xmp.Rating %s" %s',
      $rating, escapeshellarg($filename));
    print("Command: '${command}'\n");
    $output = array();
    exec($command, $output, $result);
    if ($result !== 0) {
      // Something bad happened.
      throw new Exception("Failed to set the rating of file ${filename} to ${rating}.  Command: ${command}; " . implode('; ', $output));
    }
  }

  private function setPhotoTags($filename, $tags) {
    if (empty($tags)) {
      return;
    }
    $tagString = $this->cutTagsToSize(implode(',', $tags));
    // Invoke exiv2 to set the tags.
    print("Setting the tags of ${filename} to ${tagString}.\n");
    if (strlen($tagString) > 64) {
      throw new Exception("The tags cannot exceed 64 characters for image ${filename} (tags are '${tagString}'.");
    }
    $command = sprintf('exiv2 -M"add Iptc.Application2.Keywords %s" %s',
      $tagString, escapeshellarg($filename));
    $output = array();
    exec($command, $output, $result);
    if ($result !== 0) {
      // Something bad happened.
      throw new Exception("Failed to set the tags of file ${filename} to ${tagString}.  Command: ${command};  " . implode('; ', $output));
    }
  }

  /**
   * Takes a tag string and ensures that it is not larger than the specified
   * maximum length.
   *
   * If the string is longer than the maximum length, the tags are removed
   * (longest one first) until the tags will fit in the specified space.
   */
  private function cutTagsToSize($tag_string, $max_len = 64) {
    $len = strlen($tag_string);
    if ( $len > $max_len) {
      $elements = explode(',', $tag_string);
      usort($elements, 'PhotoArchive::strLenSort');
      $total = 0;
      while (count($elements) > 0 && $len - $total > $max_len) {
        $tag = array_shift($elements);
        $total = strlen($tag) + 1;
      }
      $tag_string = implode(',', $elements);
    }
    return $tag_string;
  }

  /**
   * Sort function that sorts two strings by their length in reverse order.
   *
   * This is used to sort the tags in the case that the length of the tags
   * string is too long to figure out which tag(s) should be removed.
   */
  public static function strLenSort($a, $b) {
    return (strlen($a) - strlen($b));
  }

  private function setPhotoTimestamp($filename) {
    // Invoke exiv2 to set the timestamp to that of the exif data in the photo.
    print("Setting the timestamp of ${filename}.\n");
    $command = sprintf('exiv2 -T rename %s',
      escapeshellarg($filename));
    $output = array();
    exec($command, $output, $result);
    if ($result !== 0) {
      // Something bad happened.
      throw new Exception("Failed to set the timestamp of file ${filename}.  Command: ${command};  " . implode('; ', $output));
    }
  }

  public function parseArgs() {
    global $argv, $argc;
    // Make sure there is a command.
    if ($argc <= 1) {
      $this->help();
      return;
    }
    $major_command = $argv[1];

    // Parse all flags
    $config = new Config();
    $args = new StdClass();
    $done = FALSE;
    $extraArgs = array();
    for ($i = 2; $i < $argc && !$done; $i++) {
      switch ($argv[$i]) {
        case '-v':
          $config->setVerbose();
          break;

        case '-y':
          $args->year = $argv[++$i];
          break;

        case '-m':
          $args->month = $argv[++$i];
          break;

        case '-d':
          $args->day = $argv[++$i];
          break;

        case '-r':
        case '--rate':
          $args->rating = $argv[++$i];
          break;

        case '-t':
        case '--tag':
          $args->tag = $argv[++$i];
          break;

        case '--from':
          // format: yyyy/mm/dd
          $args->from = $argv[++$i];
          break;

        case '--to':
          // format: yyyy/mm/dd
          $args->to = $argv[++$i];
          break;

        case '--use-original-db':
	  $args->db = 'original';
	  break;

        default:
          while ($i < $argc) {
            $extraArgs[] = $argv[$i++];
          }
          $done = TRUE;
      }
    }

    $conf = $config->getConfiguration();
    // Now we have $config and $extraArgs...
    switch ($major_command) {
      case 'info':
        $this->info($conf, $args, $extraArgs);
        break;

      case 'archive-info':
        $this->archiveInfo($conf, $args, $extraArgs);
        break;

      case 'tags':
        $this->tags($conf, $args, $extraArgs);
        break;

      case 'list':
        $this->listPhotos($conf, $args, $extraArgs);
        break;

      case 'archive':
        $this->archive($conf, $args, $extraArgs);
        break;

      case 'fetch':
        $this->fetch($conf, $args, $extraArgs);
        break;

      default:
        $this->help();
    }
  }

  public function info($config, $args, $extraArgs) {
    $photoDB = new PhotoDB($config);
    for ($i = 0, $len = count($extraArgs); $i < $len; $i++) {
      $photoId = $extraArgs[$i];
      $tags = $photoDB->getTags($photoId);
      print("${photoId}: " . implode(', ', $tags) . "\n");
    }
    $photoDB->close();
  }

  /**
   * Prints info about specific photos in the original archive.
   */
  public function archiveInfo($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    for ($i = 0, $len = count($extraArgs); $i < $len; $i++) {
      $photoId = $extraArgs[$i];
      $photo = $archiveDB->loadPhoto($config, $photoId);
      print("Photo ${photoId}: ");
      print_r($photo);
      print("\n");
    }
    $archiveDB->close();
  }

  public function listPhotos($config, $args, $extraArgs) {
    if ($args->db == 'original') {
      $db = new ArchiveDB($config);
    }
    else {
      $db = new PhotoDB($config);
    }
    $photos = $db->getPhotos($args);
    $count = 0;
    while ($photo = $photos->fetchObject()) {
      $this->printPhotoInfo($photo, $config, $db);
      $count++;
    }
    print("${count} photos.\n");
    $db->close();
  }

  public function tags($config, $args, $extraArgs) {
    $photoDB = new PhotoDB($config);
    $tags = $photoDB->getAllTags();
    print(implode("\n", $tags) . "\n");
    $photoDB->close();
  }

  public function archive($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    $photoDB = new PhotoDB($config);
    $photos = $photoDB->getPhotos($args);
    $count = 0;
    while ($photo = $photos->fetchObject()) {
      $this->archiveOriginalPhoto($config, $photo, $photoDB, $archiveDB);
      $count++;
    }
    print("${count} photos matched your query.\n");
    $photoDB->close();
  }

  public function fetch($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    $photos = $archiveDB->getPhotos($args);
    $count = 0;
    switch (count($extraArgs)) {
      case 0:
        $dest = getcwd();
        break;

      case 1:
        $dest = $extraArgs[0];
        break;

      default:
        throw new Exception("Destination directory is not specified.");
    }
    if (!is_dir($dest)) {
      throw new Exception("Destination directory ${dest} does not exist or is not a directory.");
    }

    $prefix = $config->shareDirectory;
    while ($photo = $photos->fetchObject()) {
      $from = $prefix . "/" . $photo->web_filename;
      $to = $dest . "/" . basename($photo->web_filename);
      if (!@copy($from, $to)) {
        print("Failed to copy ${from} to ${to}.\n");
      }
      else {
        print("Copied ${from} to ${to}.\n");
      }
      $count++;
    }
    print("${count} photos matched your query.\n");
    $archiveDB->close();
  }

  public function main() {
    // Figure out where the application lives.
    global $argv, $argc, $app_dir;
    $app_dir = dirname($argv[0]);

    $this->includes();
    $this->parseArgs();
    return;
    $pa = new PhotoArchive();
    $pa->includes();
    $c = new Config();
    $options = getopt('p:vr:t:'/*, array('rate:', 'tag:')*/);
    if (isset($options['v'])) {
      $c->setVerbose();
    }
    $config = $c->getConfiguration();;

    if (isset($options['p'])) {
      $photoId = $options['p'];
      $photoDB = new PhotoDB($config);
      $tags = $photoDB->getTags($photoId);
      print(implode(', ', $tags) . "\n");
      $photoDB->close();
      die();
    }
    $photoDB = new PhotoDB($config);
    $rate = empty($options['r']) ? NULL : $options['r'];
    $results = $photoDB->find($rate);
    $count = 0;
    /*
    foreach ($results as $row) {
      foreach ($row as $key => $val) {
	if (!is_numeric($key)) {
	  print "$key: $val\n";
	}
      }
      $count++;
    }
    */
    while ($photo = $results->fetchObject()) {
      /*      foreach ($result as $key => $val) {
	if (!is_numeric($key)) {
	  print "$key: $val\n";
	}
      }
      */
      $pa->archiveOriginalPhoto($config, $photo, $photoDB);
      $count++;
    }
    print("${count} photos matched your query.\n");
    $photoDB->close();
  }
}

$pa = new PhotoArchive();
$pa->main();

