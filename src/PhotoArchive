#!/usr/bin/php
<?php

class PhotoArchive {

  public function help() {
    $help = <<<EOT
PhotoArchive
Usage:  PhotoArchive COMMAND [OPTION...]

Commands:
  archive - Archives the set of images from the picture_directory identified in the configuration file to the originals_directory.  Information will be added to the originals database for all images that are archived.

  archive-info - Prints information about the specified photos within the orgininals archive.

  help - Prints a help message

  info - Prints information about the specified photos within the photo database.

  list - Prints information about the specified photos within the photo database.

  tags - Prints tag information about the specified photos.

OPTIONS:

  -v - Turn on verbose mode

  -r - Specify the rank of the photos that you are interested in.  For example, -r 3 will select all photos with a rank of 3.  Also, '-r ">=3"' will select all photos with a rank of 3 or more.

  -t - Specify a tag of interest.  This will narrow the list of pictures to only those that have the specified tag.

  --from - Specify a from date.  Of the form yyyy/mm/dd.

  --to - Specify a to date.  Of the form yyyy/mm/dd.  With --from and --to you can identify the range of pictures you are interested in.

  --use-original-db - Use the original db rather than the photo db.

EOT;
    print("${help}\n");
  }

  private function includes() {
    global $app_dir;
    include_once("$app_dir/Config.php");
    include_once("$app_dir/PhotoDB.php");
    include_once("$app_dir/ArchiveDB.php");
  }

  public function printPhotoInfo($photo, $config, $db) {
    if (isset($photo->id)) {
      $out[] = "ID: " . $photo->id;
    }
    else if (isset($photo->pid)) {
      $out[] = "ID: " . $photo->pid;
    }
    $out[] = "Filename: " . $photo->filename;
    $out[] = "Rating: " . $photo->rating;
    $out[] = "Dimensions: " . $photo->width . 'x' . $photo->height;
    $out[] = "MD5: " . $photo->md5;
    if (isset($photo->id)) {
      $tags = $db->getTags($photo->id);
    }
    else if (isset($photo->pid)) {
      $tags = $db->getTags($photo->pid);
    }
    if (count($tags) > 0) {
      $out[] = "Tags: " . implode(', ', $tags);
    }
    print(implode("\n", $out) . "\n");
  }

  /**
   * Causes the specfied photo to be archived.
   */
  private function archiveOriginalPhoto($config, $photo, $photoDB, $archiveDB) {
    $archivedPhoto = new StdClass();
    $escapedPath = preg_replace('/\//', '\\\/', $config->pictureDirectory);
    $partialPath = preg_replace('/^' . $escapedPath . '/', '', $photo->filename);;
    $archivedPhoto->filename = $partialPath;
    $filename = $config->originalsDirectory . $partialPath;

    $archivedPhoto->width = $photo->width;
    $archivedPhoto->height = $photo->height;
    $archivedPhoto->exposure_time = $photo->exposure_time;
    $archivedPhoto->rating = $photo->rating;

    // Get the photo tags...
    $tags = $photoDB->getTags($photo->id);
    $archivedPhoto->tags = $tags;

    // Create the directory if needed...
    $dir = dirname($filename);
    if (!file_exists($dir)) {
      mkdir($dir, 0755, TRUE);
    }

    if (!copy($photo->filename, $filename)) {
      throw new Exception("Failed to copy " . $photo->filename . " to ${filename}");
    }
    $info = pathinfo($photo->filename);
    $ext = strtoupper($info['extension']);
    if ($ext == 'JPG') {
      $this->setPhotoRating($filename, $archivedPhoto->rating);
      $this->setPhotoTags($filename, $tags);
    }
    $this->setPhotoTimestamp($filename);
    $archivedPhoto->md5 = md5_file($filename);

    $this->createJPEG($config, $archivedPhoto, $archiveDB);
    $this->createWebJPEG($config, $archivedPhoto, $archiveDB);
    $archiveDB->updatePhoto($archivedPhoto);
  }

  private function createJPEG($config, &$photo, $db) {
    $original = $config->originalsDirectory . $photo->filename;
    $parts = pathinfo($photo->filename);
    $jpeg_filename = $parts['dirname'] . '/' . $parts['filename'] . '.JPG';
    $jpeg = $config->jpegsDirectory . $jpeg_filename;

    // Create the directory if needed...
    $dir = dirname($jpeg);
    if (!file_exists($dir)) {
      mkdir($dir, 0755, TRUE);
    }
    $type = $this->getPhotoType($original);
    switch ($type) {
    case 'JPG':
      // No conversion needed.
      if (!copy ($original, $jpeg)) {
	throw new Exception("Failed to copy ${original} to ${jpeg}.");
      }
      break;

    case 'NEF':
      print("converting " . $original . " to ${jpeg}\n");
      $command = sprintf('ufraw-batch --compression=99 --wb=auto --exposure=auto --base-curve=camera --overwrite --out-type=jpeg --output=%s %s',
        escapeshellarg($jpeg), escapeshellarg($original));
      $output = array();
      exec($command, $output, $result);
      if ($result !== 0) {
	// Something bad happened.
	throw new Exception("Failed to convert file ${original} to ${jpeg}.  " . implode('; ', $output));
      }
      break;

    default:
      throw new Exception("Unexpected file type: ${type}.");
    }
    $this->setPhotoRating($jpeg, $photo->rating);
    $this->setPhotoTags($jpeg, $photo->tags);
    $this->setPhotoTimestamp($jpeg);
    $photo->jpeg_filename = $jpeg_filename;
    $photo->jpeg_md5 = md5_file($jpeg);
  }

  private function createWebJPEG($config, &$photo, $db) {
    $full_filename = $config->jpegsDirectory . $photo->jpeg_filename;
    $web_filename = $config->shareDirectory . $photo->jpeg_filename;

    // Create the directory if needed...
    $dir = dirname($web_filename);
    if (!file_exists($dir)) {
      mkdir($dir, 0755, TRUE);
    }
    list($width, $height) = getimagesize($full_filename);
    $matches = array();
    if (preg_match('/^([0-9]+)[xX]([0-9]+)$/', $config->shareResolution, $matches) != 1) {
      die(sprintf("Invalid share_resolution in your config file: %s\n", $config->shareResolution));
    }
    $share_width = $matches[1];
    $share_height = $matches[2];
    // Figure out the % to reduce the image...
    if ($width > $height) {
      $percent = round(("${share_width}.0" / $width) * 100);
    }
    else {
      $percent = round(("${share_height}.0" / $height) * 100);
    }
    $percent = min($percent, 100);
    print("scaling ${full_filename} to ${web_filename} by ${percent}%.\n");
    $command = sprintf('convert %s -resize %s -quality %s %s',
      escapeshellarg($full_filename), escapeshellarg("${percent}%"), escapeshellarg($config->quality), escapeshellarg($web_filename));
    $output = array();
    exec($command, $output, $result);
    if ($result !== 0) {
      // Something bad happened.
      throw new Exception("Failed to scale image file ${full_filename} to ${web_filename}.  " . implode('; ', $output));
    }

    $this->setPhotoTimestamp($web_filename);
    $photo->web_filename = $photo->jpeg_filename;
    $photo->web_md5 = md5_file($web_filename);
  }

  private function getPhotoType($filename) {
    $info = pathinfo($filename);
    $ext = strtoupper($info['extension']);
    return $ext;
  }

  private function copyPhoto($from, $to) {
    // Copy the file, preserving the timestamp, etc.
    print("Copying " . $from . " to $to\n");
    $copy = 'cp -p ' . escapeshellarg($from) . ' ' . escapeshellarg($to);
    $output = array();
    exec($copy, $output, $result);
    if ($result !== 0) {
      // Something bad happened.
      throw new Exception("Failed to copy file " . $from . " to ${to}.  " . implode('; ', $output));
    }
  }

  private function setPhotoRating($filename, $rating) {
    // Invoke exiv2 to set the rating.
    print("Setting the rating of ${filename} to ${rating}.\n");
    if ($rating < 0 || $rating > 5) {
      // This is not a legal rating.
      throw new Exception("Rating must be between 0 and 5, inclusive.  Instead it was ${rating} for file ${filename}.");
    }
    $command = sprintf('exiv2 -M"add Xmp.xmp.Rating %s" %s',
      $rating, escapeshellarg($filename));
    print("Command: '${command}'\n");
    $output = array();
    exec($command, $output, $result);
    if ($result !== 0) {
      // Something bad happened.
      throw new Exception("Failed to set the rating of file ${filename} to ${rating}.  " . implode('; ', $output));
    }
  }

  private function setPhotoTags($filename, $tags) {
    if (empty($tags)) {
      return;
    }
    $tagString = implode(',', $tags);
    // Invoke exiv2 to set the tags.
    print("Setting the tags of ${filename} to ${tagString}.\n");
    if (strlen($tagString) > 64) {
      throw new Exception("The tags cannot exceed 64 characters for image ${filename} (tags are '${tagString}'.");
    }
    $command = sprintf('exiv2 -M"add Iptc.Application2.Keywords %s" %s',
      $tagString, escapeshellarg($filename));
    $output = array();
    exec($command, $output, $result);
    if ($result !== 0) {
      // Something bad happened.
      throw new Exception("Failed to set the tags of file ${filename} to ${tagString}.  " . implode('; ', $output));
    }
  }

  private function setPhotoTimestamp($filename) {
    // Invoke exiv2 to set the timestamp to that of the exif data in the photo.
    print("Setting the timestamp of ${filename}.\n");
    $command = sprintf('exiv2 -T rename %s',
      escapeshellarg($filename));
    $output = array();
    exec($command, $output, $result);
    if ($result !== 0) {
      // Something bad happened.
      throw new Exception("Failed to set the timestamp of file ${filename}.  " . implode('; ', $output));
    }
  }

  public function parseArgs() {
    global $argv, $argc;
    // Make sure there is a command.
    if ($argc <= 1) {
      $this->help();
      return;
    }
    $major_command = $argv[1];

    // Parse all flags
    $config = new Config();
    $args = new StdClass();
    $done = FALSE;
    $extraArgs = array();
    for ($i = 2; $i < $argc && !$done; $i++) {
      switch ($argv[$i]) {
        case '-v':
          $config->setVerbose();
          break;

        case '-y':
          $args->year = $argv[++$i];
          break;

        case '-m':
          $args->month = $argv[++$i];
          break;

        case '-d':
          $args->day = $argv[++$i];
          break;

        case '-r':
        case '--rate':
          $args->rating = $argv[++$i];
          break;

        case '-t':
        case '--tag':
          $args->tag = $argv[++$i];
          break;

        case '--from':
          // format: yyyy/mm/dd
          $args->from = $argv[++$i];
          break;

        case '--to':
          // format: yyyy/mm/dd
          $args->to = $argv[++$i];
          break;

        case '--use-original-db':
	  $args->db = 'original';
	  break;

        default:
          while ($i < $argc) {
            $extraArgs[] = $argv[$i++];
          }
          $done = TRUE;
      }
    }

    $conf = $config->getConfiguration();
    // Now we have $config and $extraArgs...
    switch ($major_command) {
      case 'info':
        $this->info($conf, $args, $extraArgs);
        break;

      case 'archive-info':
        $this->archiveInfo($conf, $args, $extraArgs);
        break;

      case 'tags':
        $this->tags($conf, $args, $extraArgs);
        break;

      case 'list':
        $this->listPhotos($conf, $args, $extraArgs);
        break;

      case 'archive':
        $this->archive($conf, $args, $extraArgs);
        break;

      default:
        $this->help();
    }
  }

  public function info($config, $args, $extraArgs) {
    $photoDB = new PhotoDB($config);
    for ($i = 0, $len = count($extraArgs); $i < $len; $i++) {
      $photoId = $extraArgs[$i];
      $tags = $photoDB->getTags($photoId);
      print("${photoId}: " . implode(', ', $tags) . "\n");
    }
    $photoDB->close();
  }

  /**
   * Prints info about specific photos in the original archive.
   */
  public function archiveInfo($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    for ($i = 0, $len = count($extraArgs); $i < $len; $i++) {
      $photoId = $extraArgs[$i];
      $photo = $archiveDB->loadPhoto($config, $photoId);
      print("Photo ${photoId}: ");
      print_r($photo);
      print("\n");
    }
    $archiveDB->close();
  }

  public function listPhotos($config, $args, $extraArgs) {
    if ($args->db == 'original') {
      $db = new ArchiveDB($config);
    }
    else {
      $db = new PhotoDB($config);
    }
    $photos = $db->getPhotos($args);
    $count = 0;
    while ($photo = $photos->fetchObject()) {
      $this->printPhotoInfo($photo, $config, $db);
      $count++;
    }
    print("${count} photos.\n");
    $db->close();
  }

  public function tags($config, $args, $extraArgs) {
    $photoDB = new PhotoDB($config);
    $tags = $photoDB->getAllTags();
    print(implode("\n", $tags) . "\n");
    $photoDB->close();
  }

  public function archive($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    $photoDB = new PhotoDB($config);
    $photos = $photoDB->getPhotos($args);
    $count = 0;
    while ($photo = $photos->fetchObject()) {
      $this->archiveOriginalPhoto($config, $photo, $photoDB, $archiveDB);
      $count++;
    }
    print("${count} photos matched your query.\n");
    $photoDB->close();
  }

  public function main() {
    // Figure out where the application lives.
    global $argv, $argc, $app_dir;
    $app_dir = dirname($argv[0]);

    $this->includes();
    $this->parseArgs();
    return;
    $pa = new PhotoArchive();
    $pa->includes();
    $c = new Config();
    $options = getopt('p:vr:t:'/*, array('rate:', 'tag:')*/);
    if (isset($options['v'])) {
      $c->setVerbose();
    }
    $config = $c->getConfiguration();;

    if (isset($options['p'])) {
      $photoId = $options['p'];
      $photoDB = new PhotoDB($config);
      $tags = $photoDB->getTags($photoId);
      print(implode(', ', $tags) . "\n");
      $photoDB->close();
      die();
    }
    $photoDB = new PhotoDB($config);
    $rate = empty($options['r']) ? NULL : $options['r'];
    $results = $photoDB->find($rate);
    $count = 0;
    /*
    foreach ($results as $row) {
      foreach ($row as $key => $val) {
	if (!is_numeric($key)) {
	  print "$key: $val\n";
	}
      }
      $count++;
    }
    */
    while ($photo = $results->fetchObject()) {
      /*      foreach ($result as $key => $val) {
	if (!is_numeric($key)) {
	  print "$key: $val\n";
	}
      }
      */
      $pa->archiveOriginalPhoto($config, $photo, $photoDB);
      $count++;
    }
    print("${count} photos matched your query.\n");
    $photoDB->close();
  }
}

$pa = new PhotoArchive();
$pa->main();

