#!/usr/bin/php
<?php

define('PHOTO', 'photo');
define('MOVIE', 'movie');

class PhotoArchive {

  public function help() {
    $help = <<<EOT
PhotoArchive
Usage:  PhotoArchive COMMAND [OPTION...]

Commands:
  archive - Archives the set of images from the picture_directory identified in the configuration file to the originals_directory.  Information will be added to the originals database for all images that are archived.

  archive-movies - Archives the set of movies from the picture_directory identified in the configuration file to the movies_directory.  Information will be added to the database for all movies that are archived.

  archive-info - Prints information about the specified photos within the orgininals archive.  Pass the photo id of each image you are interested in as arguments.

  help - Prints a help message

  info - Prints information about the specified photos within the photo database.

  list - Prints information about the specified photos within the photo database.

  list-movies - Prints information about the specified movies within the photo database.

  tags - Prints tag information about the specified photos.

  fetch - Fetches specified photos.  By default the sharable size photo is fetched.
         --full-size - Fetch the full size JPEG image instead.
         --original-size - Fetch the original image instead.

  fetch-movies - Fetches specified movies.

  remove - Removes specified photos from the archive.  They will be removed from the database and the photos will be removed.

  edit <md5sum> - Edits the image that correpsonds to the specified md5 sum.  All lower level images are regenerated from the modified image.  Note that the original image is never modified as a result.  Editing the original raw image will allow you to adjust the white balance and exposure and save those changes to the full size jpeg without actually changing the original image in the archive.

  revert - Reverts the image.  This regenerates the derivative images from the original.

OPTIONS:

  -v - Turn on verbose mode

  -r - Specify the rank of the photos that you are interested in.  For example, -r 3 will select all photos with a rank of 3.  Also, '-r ">=3"' will select all photos with a rank of 3 or more.

  -t - Specify a tag of interest.  This will narrow the list of pictures to only those that have the specified tag.

  --from - Specify a from date.  Of the form yyyy/mm/dd.

  --to - Specify a to date.  Of the form yyyy/mm/dd.  With --from and --to you can identify the range of pictures you are interested in.

  --use-original-db - Use the original db rather than the photo db.

EOT;
    print("${help}\n");
  }

  private function includes() {
    global $app_dir;
    include_once("$app_dir/Config.php");
    include_once("$app_dir/PhotoDB.php");
    include_once("$app_dir/ArchiveDB.php");
  }

  public function printPhotoInfo($photo, $config, $db) {
    if (isset($photo->id)) {
      $out[] = "ID: " . $photo->id;
    }
    else if (isset($photo->pid)) {
      $out[] = "ID: " . $photo->pid;
    }
    $out[] = "Filename: " . $photo->filename;
    $out[] = "Rating: " . $photo->rating;
    $out[] = "Dimensions: " . $photo->width . 'x' . $photo->height;
    $out[] = "MD5: " . $photo->md5;
    if (isset($photo->id)) {
      $tags = $db->getTags($photo->id, PHOTO);
    }
    else if (isset($photo->pid)) {
      $tags = $db->getTags($photo->pid, PHOTO);
    }
    if (count($tags) > 0) {
      $out[] = "Tags: " . implode(', ', $tags);
    }
    if (isset($photo->modified)) {
      $out[] = "Modified: " . ($photo->modified ? "TRUE" : "FALSE");
    }
    print(implode("\n", $out) . "\n");
  }

  public function printMovieInfo($movie, $config, $db) {
    if (isset($movie->id)) {
      $out[] = "ID: " . $movie->id;
    }
    else if (isset($movie->mid)) {
      $out[] = "ID: " . $movie->id;
    }
    $out[] = "Filename: " . $movie->filename;
    $out[] = "Rating: " . $movie->rating;
    $out[] = "Dimensions: " . $movie->width . 'x' . $movie->height;
    $out[] = "MD5: " . $movie->md5;

    if (isset($movie->id)) {
      $tags = $db->getTags($movie->id, MOVIE);
    }
    else if (isset($movie->mid)) {
      $tags = $db->getTags($movie->mid, MOVIE);
    }
    if (count($tags) > 0) {
      $out[] = "Tags: " . implode(', ', $tags);
    }
    print(implode("\n", $out) . "\n");
  }

  /**
   * Causes the specfied photo to be archived.
   */
  private function archiveOriginalPhoto($config, $photo, $photoDB, $archiveDB, $overwrite = FALSE) {
    $archivedPhoto = new StdClass();
    $escapedPath = preg_replace('/\//', '\\\/', $config->pictureDirectory);
    $partialPath = preg_replace('/^' . $escapedPath . '/', '', $photo->filename);;
    $archivedPhoto->filename = $partialPath;
    $filename = $config->originalsDirectory . $partialPath;

    $archivedPhoto->width = $photo->width;
    $archivedPhoto->height = $photo->height;
    $archivedPhoto->exposure_time = $photo->exposure_time;
    $archivedPhoto->rating = $photo->rating;
    $archivedPhoto->modified = FALSE;

    // Get the photo tags...
    $tags = $photoDB->getTags($photo->id, PHOTO);
    $archivedPhoto->tags = $tags;

    if (!$overwrite && file_exists($filename)) {
      // Do nothing - the file already exists.
      print("Skipping file $filename\n");
    }
    else {
      print("Copying file $filename\n");
      // Create the directory if needed...
      $dir = dirname($filename);
      if (!file_exists($dir)) {
        mkdir($dir, 0755, TRUE);
      }

      if (!copy($photo->filename, $filename)) {
        throw new Exception("Failed to copy " . $photo->filename . " to ${filename}");
      }
      $this->setPhotoTimestamp($filename);
    }

    $archivedPhoto->md5 = md5_file($filename);
    $this->createJPEG($config, $archivedPhoto, $archiveDB, $overwrite);
    $this->createWebJPEG($config, $archivedPhoto, $archiveDB, $overwrite);
    $archiveDB->updatePhoto($archivedPhoto);
  }

  /**
   * Causes the specfied movie to be archived.
   */
  private function archiveMovie($config, $movie, $photoDB, $archiveDB, $overwrite = FALSE) {
    $archivedMovie = new StdClass();
    $escapedPath = preg_replace('/\//', '\\\/', $config->pictureDirectory);
    $partialPath = preg_replace('/^' . $escapedPath . '/', '', $movie->filename);;
    $archivedMovie->filename = $partialPath;
    $filename = $config->movieDirectory . $partialPath;

    $archivedMovie->width = $movie->width;
    $archivedMovie->height = $movie->height;
    $archivedMovie->exposure_time = $movie->exposure_time;
    $archivedMovie->rating = $movie->rating;
    $archivedMovie->modified = FALSE;

    // Get the photo tags...
    $tags = $photoDB->getTags($movie->id, MOVIE);
    $archivedMovie->tags = $tags;

    if (!$overwrite && file_exists($filename)) {
      // Do nothing - the file already exists.
      print("Skipping file $filename\n");
    }
    else {
      print("Copying file $filename\n");
      // Create the directory if needed...
      $dir = dirname($filename);
      if (!file_exists($dir)) {
        mkdir($dir, 0755, TRUE);
      }

      if (!copy($movie->filename, $filename)) {
        throw new Exception("Failed to copy " . $movie->filename . " to ${filename}");
      }
      touch($filename, $movie->exposure_time);
    }

    $archivedMovie->md5 = md5_file($filename);
    $archiveDB->updateMovie($archivedMovie);
  }

  private function createJPEG($config, &$photo, $db, $overwrite = FALSE) {
    $original = $config->originalsDirectory . $photo->filename;
    $parts = pathinfo($photo->filename);
    $jpeg_filename = $parts['dirname'] . '/' . $parts['filename'] . '.JPG';
    $jpeg = $config->jpegsDirectory . $jpeg_filename;
    $modified_filename = $config->pictureDirectory . $parts['dirname'] . '/' . $parts['filename'] . '_modified.';

    if (!$overwrite && file_exists($jpeg)) {
      // The file exists, do nothing.
    }
    else {
      // Create the directory if needed...
      $dir = dirname($jpeg);
      if (!file_exists($dir)) {
        mkdir($dir, 0755, TRUE);
      }

      // Is there a modified picture available?
      if (file_exists($modified_filename . 'JPG')) {
        $modified = $modified_filename . 'JPG';
      }
      else if (file_exists($modified_filename . 'jpg')) {
        $modified = $modified_filename . 'jpg';
      }
      if (!empty($modified)) {
        if (!copy ($modified, $jpeg)) {
          throw new Exception("Failed to copy ${modified} to ${jpeg}.");
        }
        $photo->modified = TRUE;
      }
      else {
        $type = $this->getPhotoType($original);
        switch ($type) {
          case 'JPG':
            // No conversion needed.
            if (!copy ($original, $jpeg)) {
              throw new Exception("Failed to copy ${original} to ${jpeg}.");
            }
            break;

          case 'NEF':
            if ($config->verbose) {
              print("converting " . $original . " to ${jpeg}\n");
            }
            $command = sprintf("ufraw-batch --compression=99 --wb=auto --exposure=auto --base-curve=camera --overwrite --out-type=jpeg --output=%s %s 2>&1",
                       escapeshellarg($jpeg), escapeshellarg($original));
            $output = array();
            exec($command, $output, $result);
            if ($result !== 0) {
              // Something bad happened.
              throw new Exception("Failed to convert file ${original} to ${jpeg}.  " . implode('; ', $output));
            }
            break;

          default:
            throw new Exception("Unexpected file type: ${type}.");
        }
      }
      $this->setPhotoRating($jpeg, $photo->rating);
      $this->setPhotoTags($jpeg, $photo->tags);
      $this->setPhotoTimestamp($jpeg);
    }
    $photo->jpeg_filename = $jpeg_filename;
    $photo->jpeg_md5 = md5_file($jpeg);
  }

  private function createWebJPEG($config, &$photo, $db, $overwrite = FALSE) {
    $full_filename = $config->jpegsDirectory . $photo->jpeg_filename;
    $web_filename = $config->shareDirectory . $photo->jpeg_filename;

    if (!$overwrite && file_exists($web_filename)) {
      // The file exists already.
    }
    else {
      // Create the directory if needed...
      $dir = dirname($web_filename);
      if (!file_exists($dir)) {
        mkdir($dir, 0755, TRUE);
      }
      list($width, $height) = getimagesize($full_filename);
      $matches = array();
      if (preg_match('/^([0-9]+)[xX]([0-9]+)$/', $config->shareResolution, $matches) != 1) {
        die(sprintf("Invalid share_resolution in your config file: %s\n", $config->shareResolution));
      }
      $share_width = $matches[1];
      $share_height = $matches[2];
      // Figure out the % to reduce the image...
      if ($width > $height) {
        $percent = round(("${share_width}.0" / $width) * 100);
      }
      else {
        $percent = round(("${share_height}.0" / $height) * 100);
      }
      $percent = min($percent, 100);
      if ($config->verbose) {
        print("scaling ${full_filename} to ${web_filename} by ${percent}%.\n");
      }
      $command = sprintf('convert %s -resize %s -quality %s %s',
        escapeshellarg($full_filename), escapeshellarg("${percent}%"), escapeshellarg($config->quality), escapeshellarg($web_filename));
      $output = array();
      exec($command, $output, $result);
      if ($result !== 0) {
        // Something bad happened.
        throw new Exception("Failed to scale image file ${full_filename} to ${web_filename}.  " . implode('; ', $output));
      }

      $this->setPhotoTimestamp($web_filename);
    }
    $photo->web_filename = $photo->jpeg_filename;
    $photo->web_md5 = md5_file($web_filename);
  }

  private function getPhotoType($filename) {
    $info = pathinfo($filename);
    $ext = strtoupper($info['extension']);
    return $ext;
  }

  private function copyPhoto($from, $to) {
    // Copy the file, preserving the timestamp, etc.
    $copy = 'cp -p ' . escapeshellarg($from) . ' ' . escapeshellarg($to);
    $output = array();
    exec($copy, $output, $result);
    if ($result !== 0) {
      // Something bad happened.
      throw new Exception("Failed to copy file " . $from . " to ${to}.  " . implode('; ', $output));
    }
  }

  private function setPhotoRating($filename, $rating) {
    // Invoke exiv2 to set the rating.
    if ($rating < 0 || $rating > 5) {
      // This is not a legal rating.
      throw new Exception("Rating must be between 0 and 5, inclusive.  Instead it was ${rating} for file ${filename}.");
    }
    $command = sprintf('exiv2 -M"add Xmp.xmp.Rating %s" %s',
      $rating, escapeshellarg($filename));
    $output = array();
    exec($command, $output, $result);
    if ($result !== 0) {
      // Something bad happened.
      throw new Exception("Failed to set the rating of file ${filename} to ${rating}.  Command: ${command}; " . implode('; ', $output));
    }
  }

  private function setPhotoTags($filename, $tags) {
    if (empty($tags)) {
      return;
    }
    $tagString = $this->cutTagsToSize(implode(',', $tags));
    if (count($tagString) > 0) {
      // Invoke exiv2 to set the tags.
      if (strlen($tagString) > 64) {
        throw new Exception("The tags cannot exceed 64 characters for image ${filename} (tags are '${tagString}'.");
      }
      $command = sprintf('exiv2 -M"add Iptc.Application2.Keywords %s" %s',
        $tagString, escapeshellarg($filename));
      $output = array();
      exec($command, $output, $result);
      if ($result !== 0) {
        // Something bad happened.
        throw new Exception("Failed to set the tags of file ${filename} to ${tagString}.  Command: ${command};  " . implode('; ', $output));
      }
    }
  }

  /**
   * Takes a tag string and ensures that it is not larger than the specified
   * maximum length.
   *
   * If the string is longer than the maximum length, the tags are removed
   * (longest one first) until the tags will fit in the specified space.
   */
  private function cutTagsToSize($tag_string, $max_len = 64) {
    $len = strlen($tag_string);
    if ( $len > $max_len) {
      $elements = explode(',', $tag_string);
      usort($elements, 'PhotoArchive::strLenSort');
      $total = 0;
      while (count($elements) > 0 && $len - $total > $max_len) {
        $tag = array_shift($elements);
        $total += strlen($tag) + 1;
      }
      $tag_string = implode(',', $elements);
    }
    return $tag_string;
  }

  /**
   * Sort function that sorts two strings by their length in reverse order.
   *
   * This is used to sort the tags in the case that the length of the tags
   * string is too long to figure out which tag(s) should be removed.
   */
  public static function strLenSort($a, $b) {
    return (strlen($a) - strlen($b));
  }

  private function setPhotoTimestamp($filename) {
    // Invoke exiv2 to set the timestamp to that of the exif data in the photo.
    $command = sprintf('exiv2 -T rename %s',
      escapeshellarg($filename));
    $output = array();
    exec($command, $output, $result);
    if ($result !== 0) {
      // Something bad happened.
      throw new Exception("Failed to set the timestamp of file ${filename}.  Command: ${command};  " . implode('; ', $output));
    }
  }

  public function parseArgs() {
    global $argv, $argc;
    // Make sure there is a command.
    if ($argc <= 1) {
      $this->help();
      return;
    }
    $major_command = $argv[1];

    // Parse all flags
    $config = new Config();
    $args = new StdClass();
    $done = FALSE;
    $extraArgs = array();
    for ($i = 2; $i < $argc && !$done; $i++) {
      switch ($argv[$i]) {
        case '-v':
          $config->setVerbose();
          break;

        case '-y':
          $args->year = $argv[++$i];
          break;

        case '-m':
          $args->month = $argv[++$i];
          break;

        case '-d':
          $args->day = $argv[++$i];
          break;

        case '-r':
        case '--rate':
          $args->rating = $argv[++$i];
          break;

        case '-t':
        case '--tag':
          $args->tag = $argv[++$i];
          break;

        case '--from':
          // format: yyyy/mm/dd
          $args->from = $argv[++$i];
          break;

        case '--to':
          // format: yyyy/mm/dd
          $args->to = $argv[++$i];
          break;

        case '--use-original-db':
	  $args->db = 'original';
	  break;

        case '--full-size':
          $args->photo_size = 'full';
          ++$i;
          break;

        case '--original-size':
          $args->photo_size = 'original';
          ++$i;
          break;

        default:
          while ($i < $argc) {
            $extraArgs[] = $argv[$i++];
          }
          $done = TRUE;
      }
    }

    $conf = $config->getConfiguration();
    // Now we have $config and $extraArgs...
    switch ($major_command) {
      case 'info':
        $this->info($conf, $args, $extraArgs);
        break;

      case 'archive-info':
        $this->archiveInfo($conf, $args, $extraArgs);
        break;

      case 'tags':
        $this->tags($conf, $args, $extraArgs);
        break;

      case 'list':
        $this->listPhotos($conf, $args, $extraArgs);
        break;

      case 'list-movies':
        $this->listMovies($conf, $args, $extraArgs);
        break;

      case 'archive':
        $this->archive($conf, $args, $extraArgs);
        break;

      case 'archive-movies':
        $this->archiveMovies($conf, $args, $extraArgs);
        break;

      case 'fetch':
        $this->fetch($conf, $args, $extraArgs);
        break;

      case 'fetch-movies':
        $this->fetchMovies($conf, $args, $extraArgs);
        break;

      case 'remove':
        $this->remove($conf, $args, $extraArgs);
        break;

      case 'edit':
        $this->edit($conf, $args, $extraArgs);
        break;

      case 'revert':
        $this->revert($conf, $args, $extraArgs);
        break;

      default:
        $this->help();
    }
  }

  public function info($config, $args, $extraArgs) {
    $photoDB = new PhotoDB($config);
    for ($i = 0, $len = count($extraArgs); $i < $len; $i++) {
      $photoId = $extraArgs[$i];
      $tags = $photoDB->getTags($photoId, PHOTO);
      print("${photoId}: " . implode(', ', $tags) . "\n");
    }
    $photoDB->close();
  }

  /**
   * Prints info about specific photos in the original archive.
   */
  public function archiveInfo($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    for ($i = 0, $len = count($extraArgs); $i < $len; $i++) {
      $photoId = $extraArgs[$i];
      $photo = $archiveDB->loadPhoto($config, $photoId);
      print("Photo ${photoId}: ");
      print_r($photo);
      print("\n");
    }
    $archiveDB->close();
  }

  public function listPhotos($config, $args, $extraArgs) {
    if (isset($args->db) && $args->db == 'original') {
      $db = new ArchiveDB($config);
    }
    else {
      $db = new PhotoDB($config);
    }
    $photos = $db->getPhotos($config, $args);
    $count = 0;
    while ($photo = $photos->fetchObject()) {
      $this->printPhotoInfo($photo, $config, $db);
      $count++;
    }
    print("${count} photos.\n");
    $db->close();
  }

  public function listMovies($config, $args, $extraArgs) {
    if (isset($args->db) && $args->db == 'original') {
      $db = new ArchiveDB($config);
    }
    else {
      $db = new PhotoDB($config);
    }
    $movies = $db->getMovies($config, $args);
    $count = 0;
    while ($movie = $movies->fetchObject()) {
      $this->printMovieInfo($movie, $config, $db);
      $count++;
    }
    print("${count} movies.\n");
    $db->close();
  }

  public function tags($config, $args, $extraArgs) {
    $photoDB = new PhotoDB($config);
    $tags = $photoDB->getAllTags();
    $photoDB->close();
  }

  public function archive($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    $photoDB = new PhotoDB($config);
    $photos = $photoDB->getPhotos($config, $args);
    $count = 0;
    while ($photo = $photos->fetchObject()) {
      $this->archiveOriginalPhoto($config, $photo, $photoDB, $archiveDB);
      $count++;
    }
    print("${count} photos matched your query.\n");
    $photoDB->close();
  }

  public function archiveMovies($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    $photoDB = new PhotoDB($config);
    $movies = $photoDB->getMovies($config, $args);
    $count = 0;
    while ($movie = $movies->fetchObject()) {
      $this->archiveMovie($config, $movie, $photoDB, $archiveDB);
      $count++;
    }
    print("${count} movies matched your query.\n");
    $photoDB->close();
  }

  public function fetch($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    $photos = $archiveDB->getPhotos($config, $args);
    $count = 0;
    switch (count($extraArgs)) {
      case 0:
        $dest = getcwd();
        break;

      case 1:
        $dest = $extraArgs[0];
        break;

      default:
        throw new Exception("Destination directory is not specified.");
    }
    if (!is_dir($dest)) {
      throw new Exception("Destination directory ${dest} does not exist or is not a directory.");
    }

    $prefix = $config->shareDirectory;
    while ($photo = $photos->fetchObject()) {
      $from = $this->getPhotoFilename($config, $args, $photo);
      $to = $dest . "/" . basename($from);
      if (!@copy($from, $to)) {
        print("Failed to copy ${from} to ${to}.\n");
      }
      else {
        $this->setPhotoTimestamp($to);
        print("Copied ${from} to ${to}.\n");
      }
      $count++;
    }
    print("${count} photos matched your query.\n");
    $archiveDB->close();
  }

  public function fetchMovies($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    $movies = $archiveDB->getMovies($config, $args);
    $count = 0;
    switch (count($extraArgs)) {
      case 0:
        $dest = getcwd();
        break;

      case 1:
        $dest = $extraArgs[0];
        break;

      default:
        throw new Exception("Destination directory is not specified.");
    }
    if (!is_dir($dest)) {
      throw new Exception("Destination directory ${dest} does not exist or is not a directory.");
    }

    $prefix = $config->movieDirectory;
    while ($movie = $movies->fetchObject()) {
      $from = $config->movieDirectory . '/' . $movie->filename;
      $to = $dest . "/" . basename($from);
      if (!@copy($from, $to)) {
        print("Failed to copy ${from} to ${to}.\n");
      }
      else {
        touch($to, $movie->exposure_time);
        print("Copied ${from} to ${to}.\n");
      }
      $count++;
    }
    print("${count} movies matched your query.\n");
    $archiveDB->close();
  }

  /**
   * Returns the correct path to the photo based on the command line arguments.
   *
   * This is currently used in the fetch method to allow the user to identify
   * which variant of the photo is desired.
   *
   * @param {Config} $config
   *   The configuration object that identifies where the database and photo
   *   directories are.
   * @param {StdClass} $args
   *   The processed command line arguments that identify which of the photo
   *   variants the user is interested in.
   * @param {StdClass} $photo
   *   A representation of the photo, loaded from the database.
   */
  private function getPhotoFilename($config, $args, $photo) {
    if (empty($args->photo_size)) {
      $type = 'web';
    }
    else {
      $type = $args->photo_size;
    }
    return $this->getFilename($config, $photo, $type);
  }

  /**
   * Returns the correct path to the photo based on the command line arguments.
   *
   * This is currently used in the fetch method to allow the user to identify
   * which variant of the photo is desired.
   *
   * @param {Config} $config
   *   The configuration object that identifies where the database and photo
   *   directories are.
   * @param {StdClass} $photo
   *   A representation of the photo, loaded from the database.
   * @param {String} $type
   *   Indicates the photo variant to provide the path for.  One of 'full',
   *   'original', or 'web'.
   */
  private function getFilename($config, $photo, $type) {
    switch ($type) {
      case 'full':
        $prefix = $config->jpegsDirectory;
        $filename = $photo->jpeg_filename;
        break;

      case 'original':
        $prefix = $config->originalsDirectory;
        $filename = $photo->filename;
        break;

      case 'web':
      default:
        $prefix = $config->shareDirectory;
        $filename = $photo->web_filename;
    }
    return  $prefix . "/" . $filename;
  }

  public function remove($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    $photos = $archiveDB->getPhotos($config, $args);
    $count = 0;
    $orig_prefix = $config->originalsDirectory;
    $jpeg_prefix = $config->jpegsDirectory;
    $share_prefix = $config->shareDirectory;
    while ($photo = $photos->fetchObject()) {
      $orig = $orig_prefix . $photo->filename;
      $jpeg = $jpeg_prefix . $photo->jpeg_filename;
      $share = $share_prefix . $photo->web_filename;
      if (!@unlink($orig)) {
        print("Failed to delete ${orig}.\n");
      }
      if (!@unlink($jpeg)) {
        print("Failed to delete ${jpeg}.\n");
      }
      if (!@unlink($share)) {
        print("Failed to delete ${share}.\n");
      }
      print('Deleting photo ' . $photo->filename . "\n");
      $archiveDB->remove($config, $photo);
      $count++;
    }
    print("${count} photos matched your query.\n");
    $archiveDB->close();
  }

  public function edit($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    for ($i = 0, $len = count($extraArgs); $i < $len; $i++) {
      $md5 = $extraArgs[$i];
      $photo = $archiveDB->getPhotoByMD5($config, $args, $md5);
      if (!empty($photo) && $md5 == $photo->md5) {
        // Modifying the original.  Never actually save over the original.
        $src = $this->getFilename($config, $photo, 'original');
        $dst = $this->getFilename($config, $photo, 'full');
      }
      if (!empty($photo) && $md5 == $photo->jpeg_md5) {
        // Modifying the full size jpeg.
        $src = $this->getFilename($config, $photo, 'full');
        $dst = $this->getFilename($config, $photo, 'full');
      }
      if (!empty($photo) && $md5 == $photo->web_md5) {
        // Modifying the sharable size.
        $src = $this->getFilename($config, $photo, 'web');
        $dst = $this->getFilename($config, $photo, 'web');
      }
      if (!empty($src) && !empty($dst)) {
        $this->editPhoto($config, $archiveDB, $photo, $src, $dst, $md5);
      }
      else {
        print("Could not find photo with md5 of ${md5}.\n");
      }
    }
  }

  /**
   * Edits the specified photo.  The changes are never saved to the original
   * image.  Any change done to the full size jpeg is replicated onto the
   * sharable size also.
   *
   * @param {Config} $config
   *   The configuration object that identifies where the database and photo
   *   directories are.
   * @param {ArchiveDB} $archiveDB
   *   The archiveDB instance.
   * @param {StdClass} $photo
   *   A representation of the photo, loaded from the database.
   * @param {String} $srcfilename
   *   The filename of the source image.
   * @param {String} $dstFilename
   *   The filename of the destination image.
   */
  public function editPhoto($config, $archiveDB, &$photo, $srcFilename, $dstFilename, $md5) {
    $compression = 99;
    $path_info = pathinfo($srcFilename);
    $type = strtoupper($path_info['extension']);

    switch($type) {
      case 'NEF':
        $command = sprintf('ufraw --out-type=jpg --compression=%d --output=%s %s', $compression, $dstFilename, $srcFilename);
        $md5_before = md5_file($dstFilename);
        $output = array();
        exec($command, $output, $result);
        // Figure out if the image was modified or not...
        $md5_after = md5_file($dstFilename);
        if ($md5_after == $md5_before) {
          // The image wasn't saved, so nothing to do.
          print("Image edit of file ${srcFilename} was aborted.\n");
        }
        else {
          $this->setPhotoTimestamp($dstFilename);
          $photo->jpeg_md5 = $md5_after;
          $this->createWebJPEG($config, $photo, $archiveDB, TRUE);
          $archiveDB->updatePhoto($photo);
          print("Saved edited image ${dstFilename}.  The new md5sum is ${md5_after}\n");
        }
        break;

      case 'JPG':
      case 'JPEG':
        // Copy the source image to /tmp, if the user saves changes, we will
        // have to copy that to the destination.
        $tmp_filename = '/tmp/' . basename($srcFilename);
        copy($srcFilename, $tmp_filename);

        $command = sprintf('gimp --no-splash %s', $tmp_filename);
        $md5_before = md5_file($tmp_filename);
        $output = array();
        exec($command, $output, $result);
        // Figure out if the image was modified or not...
        $md5_after = md5_file($tmp_filename);
        if ($md5_after == $md5_before) {
          // The image wasn't saved, so nothing to do.
          print("Image edit of file ${srcFilename} was aborted.\n");
        }
        else {
          copy($tmp_filename, $dstFilename);
          $this->setPhotoTimestamp($dstFilename);
          if ($md5 == $photo->jpeg_md5) {
            // The full size jpeg image was modified.
            $photo->jpeg_md5 = $md5_after;
            $this->createWebJPEG($config, $photo, $archiveDB, TRUE);
            $archiveDB->updatePhoto($photo);
          }
          elseif ($md5 == $photo->web_md5) {
            // The web size jpeg was modified.
            $photo->web_md5 = $md5_after;
            $archiveDB->updatePhoto($photo);
          }
          print("Saved edited image ${dstFilename}.  The new md5sum is ${md5_after}\n");}
        break;
    }
  }

  public function revert($config, $args, $extraArgs) {
    $archiveDB = new ArchiveDB($config);
    for ($i = 0, $len = count($extraArgs); $i < $len; $i++) {
      $md5 = $extraArgs[$i];
      $photo = $archiveDB->getPhotoByMD5($config, $args, $md5);
      if (!empty($photo)) {
        $photo = $archiveDB->loadPhoto($config, $photo->pid);
        $this->createJPEG($config, $photo, $archiveDB, TRUE);
        $this->createWebJPEG($config, $photo, $archiveDB, TRUE);
        $archiveDB->updatePhoto($photo);
        print('Reverted photo ' . $photo->filename . "\n");
      }
      else {
        print("Could not find photo associated with md5 ${md5}\n");
      }
    }
  }

  public function main() {
    // Figure out where the application lives.
    global $argv, $argc, $app_dir;
    $app_dir = dirname($argv[0]);

    $this->includes();
    $this->parseArgs();
    return;
    $pa = new PhotoArchive();
    $pa->includes();
    $c = new Config();
    $options = getopt('p:vr:t:'/*, array('rate:', 'tag:')*/);
    if (isset($options['v'])) {
      $c->setVerbose();
    }
    $config = $c->getConfiguration();;

    if (isset($options['p'])) {
      $photoId = $options['p'];
      $photoDB = new PhotoDB($config);
      $tags = $photoDB->getTags($photoId, PHOTO);
      print(implode(', ', $tags) . "\n");
      $photoDB->close();
      die();
    }
    $photoDB = new PhotoDB($config);
    $rate = empty($options['r']) ? NULL : $options['r'];
    $results = $photoDB->find($rate);
    $count = 0;
    /*
    foreach ($results as $row) {
      foreach ($row as $key => $val) {
	if (!is_numeric($key)) {
	  print "$key: $val\n";
	}
      }
      $count++;
    }
    */
    while ($photo = $results->fetchObject()) {
      /*      foreach ($result as $key => $val) {
	if (!is_numeric($key)) {
	  print "$key: $val\n";
	}
      }
      */
      $pa->archiveOriginalPhoto($config, $photo, $photoDB);
      $count++;
    }
    print("${count} photos matched your query.\n");
    $photoDB->close();
  }
}

$pa = new PhotoArchive();
$pa->main();

